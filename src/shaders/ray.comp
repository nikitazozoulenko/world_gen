#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform vec3 cam_pos;
uniform vec3 cam_dir;
uniform vec3 cam_up;

float squareSDF(vec3 p, vec3 square_middle, float s)
{   // p point which distnace is measured from. s side length.
    // NOTE: may not work inside the square
    return 0;
}


float cubeSDF(vec3 p, vec3 cube_middle, vec3 size) {
    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z
    // So if all components of d are negative, then p is inside the unit cube
    vec3 d = abs(cube_middle-p) - size;
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}



float distToSphere(vec3 p, vec3 circle_origin, float r)
{   // p point which distance is measured from. r is radius
    // NOTE: may not work inside the sphere
    return length(p-circle_origin)-r;
}
float distToSphere(vec3 p, vec4 sphere)
{
    return distToSphere(p, sphere.xyz, sphere.w);
}


float distToPlane(vec3 p, vec3 n, vec3 q)
{   // p point which distance is measured from.
    // n plane normal.
    // q a point on the plane.
    n = normalize(n);
    float dist = dot(p-q, n);
    return dist;
}


float distField(vec3 p)
{   // Returns the distance to the closes object from point p
    // in world space. This is a scalar field.

    // 2 spheres, 1 plane
    vec4 sphere0 = vec4(0,5,0,1);
    vec4 sphere1 = vec4(0,-1000,0,1000);
    vec3 n0 =  vec3(0,1,0);
    vec3 q0 = vec3(0,-2,0);

    vec3 cube_mid0 = vec3(0,0,0);
    vec3 cube_size0 = vec3(2,1,1);

    float dist = min(cubeSDF(p, cube_mid0, cube_size0), min(distToPlane(p, n0,q0), distToSphere(p, sphere0)));
    return dist;
}


float rayMarching(vec3 p, vec3 ray)
{   // Ray Marching algorithm until distance bigger than MAX_DIST_MARCH,
    // or distance less than eps or MAX_STEPS_MARCH have been taken
    float MAX_DIST_MARCH = 1000;
    int MAX_STEPS_MARCH = 1000;
    float eps = 0.001;
    float total_dist = eps;
    for (int i=0; i<MAX_STEPS_MARCH; i++)
    {
        float dist = distField(p + total_dist*ray);
        total_dist += dist;
        if (dist < eps)
            return total_dist;
        if (total_dist>=MAX_DIST_MARCH)
          return MAX_DIST_MARCH;
    }
    return total_dist;
}
            

vec3 distFieldGradient(vec3 p)
{   // Calculates the numerical gradient of the distance field
    // (normal to object surface) at point p in world space.
    vec2 eps = vec2(0.0001, 0);
    vec3 grad = vec3(distField(p+eps.xyy)-distField(p-eps.xyy), 
                     distField(p+eps.yxy)-distField(p-eps.yxy), 
                     distField(p+eps.yyx)-distField(p-eps.yyx));
    return normalize(grad);
}


float simpleLighting(vec3 p)
{   // diffuse lighting
    vec3 light_pos = vec3(-5,20,0);
    vec3 light_dir = normalize(light_pos - p);
    vec3 normal = distFieldGradient(p);
    float diffuse = clamp(dot(normal, light_dir), 0., 1.);

    // raymarch from point p on surface in the direction of the light source. if it intersects before light, then shadow
    float eps = 0.002;
    float d = rayMarching(p+normal*eps, light_dir);
    if(d<length(light_pos-p))
        diffuse *= 0.1;
    return diffuse;
}


vec3 rotate(vec3 v, vec3 axis, float rad) 
{   //Quaternion rotation
    float hr = rad / 2.0;
    float s = sin(hr);
    vec4 q = vec4(axis * s, cos(hr));
    vec3 q2 = q.xyz + q.xyz;
    vec3 qq2 = q.xyz * q2;
    vec2 qx = q.xx * q2.yz;
    float qy = q.y * q2.z;
    vec3 qw = q.w * q2.xyz;
    mat3 matRot = mat3(
        1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,
        qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,
        qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)
    );
    return matRot * v;
}


vec3 getPerspectiveProjectionRayDirection(ivec2 pixel_coords)
{   // Uniformly distributed points on sphere.
    // Scale the screen coords to [-FOV/2, FOV/2]^2
    float FOV = radians(75);
    ivec2 im_dims = imageSize(img_output);
    vec2 rot_amounts = (pixel_coords / vec2(im_dims) -0.5)*FOV;

    vec3 ray = rotate(cam_dir, cam_up, rot_amounts.x);
    ray = rotate(ray, cross(cam_up, cam_dir), rot_amounts.y);
    return normalize(ray);
}


void main() 
{
    // base pixel colour for image
    vec4 pixel = vec4(1.0, 1.0, 1.0, 1.0);

    // get index in global work group i.e x,y position.
    // Then get ray
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec3 ray = getPerspectiveProjectionRayDirection(pixel_coords);
    float dist = rayMarching(cam_pos, ray);
    vec3 p = cam_pos + ray*dist;
    float diffuse = simpleLighting(p);

    pixel = vec4(diffuse,diffuse,diffuse, 1.0);
    
    // output to a specific pixel in the image
    imageStore(img_output, pixel_coords, pixel);
}