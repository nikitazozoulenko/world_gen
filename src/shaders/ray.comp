#version 430
#define SSP_SIZE 16

layout(local_size_x=1, local_size_y=1, local_size_z=SSP_SIZE) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

layout(binding=1) uniform sampler2D texture_map;
layout(binding=2) uniform sampler2D normal_map;

uniform vec3 cam_pos;
uniform vec3 cam_dir;
uniform vec3 cam_up;
uniform float time;

shared vec3 pixel_samples[SSP_SIZE];

#define MAX_DEPTH 100000
#define PI 3.14159265359

struct Object           
{
    int type;           // -1:no obj hit, 0:sphere, 1:box, 2:plane
    int texID;          // which texture to use

    vec3 center;        // also a point which lies on the plane
    vec3 size;          // box side length
    vec3 plane_normal;  // plane normal
    float r;            // circle radius
};


struct DistObjPair
{
    float dist;
    Object obj;
};


vec3 rotate(vec3 v, vec3 axis, float rad) 
{   //Quaternion rotation
    float hr = rad / 2.0;
    float s = sin(hr);
    vec4 q = vec4(axis * s, cos(hr));
    vec3 q2 = q.xyz + q.xyz;
    vec3 qq2 = q.xyz * q2;
    vec2 qx = q.xx * q2.yz;
    float qy = q.y * q2.z;
    vec3 qw = q.w * q2.xyz;
    mat3 matRot = mat3(
        1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,
        qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,
        qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)
    );
    return matRot * v;
}


vec3 getPerspectiveProjectionRayDirection(ivec2 pixel_coords)
{   // Uniformly distributed points on sphere.
    // Scale the screen coords to [-FOV/2, FOV/2]^2
    float FOV = radians(75);
    ivec2 im_dims = imageSize(img_output);
    vec2 rot_amounts = (pixel_coords / vec2(im_dims) -0.5)*FOV;
    vec3 ray = rotate(cam_dir, cam_up, rot_amounts.x);
    ray = rotate(ray, cross(cam_up, cam_dir), rot_amounts.y);
    return normalize(ray);
}

float intersectSphere(vec3 ray_dir, vec3 pos, vec3 center, float r)
{   //returns dist to sphere. if dist==-1 then no hit.
    vec3 v = center-pos;
    float dist = -1;
    if (dot(v, ray_dir)>0)
    {   // in front of ray
        vec3 proj = v-dot(v, ray_dir)*ray_dir;
        float len = length(proj);
        if (len<=r)
        {   //intersection possible
            vec3 intersection = center - proj - (ray_dir*sqrt(r*r-len*len));
            dist = distance(intersection, pos);
        }
    }
    return dist;
}

float intersectRay(vec3 ray_dir, vec3 pos)
{
    // Only one object currently, one sphere
    vec3 center = vec3(5,5,5);
    float r = 1.0;
    float dist = intersectSphere(ray_dir, pos, center, r);
    return dist;
}


void main()
{
    // get index in global work group i.e x,y position.
    // Then get ray and cast the ray
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec3 ray_dir = getPerspectiveProjectionRayDirection(pixel_coords);

    float dist = intersectRay(ray_dir, cam_pos);
    float diff = 0;
    if(dist>=0)
    {
        diff = 1;
    }

    vec3 pixel = vec3(diff, diff, diff);
    uint sample_id = gl_LocalInvocationID.z;
    pixel_samples[sample_id] = pixel;

    //make sure all samples have been run
    memoryBarrierShared();
    barrier();
    
    //only write once per pixel location
    if(gl_LocalInvocationID.z==0)
    {   
        vec3 avg_pixel = vec3(0,0,0);
        for(int i=0; i<SSP_SIZE; i++)
        {
            avg_pixel += pixel_samples[i] / SSP_SIZE;
        }
        // output to a specific pixel in the image
        imageStore(img_output, pixel_coords, vec4(avg_pixel.xyz, 1));
    }

    
}